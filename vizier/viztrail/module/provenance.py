# Copyright (C) 2017-2019 New York University,
#                         University at Buffalo,
#                         Illinois Institute of Technology.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""The module provenance object maintains information about the datasets that
a module has read and written in previous executions and the names of those
datasets that have been deleted.

In addition to information about accessed and manipulated datasets the
provenance object allows to carry state from previous executions for a module.
"""

import os
from typing import Dict, Set, List, Any, Tuple, Optional
from vizier.view.chart import ChartViewHandle
from vizier.datastore.artifact import ArtifactDescriptor

def debug(message: str):
    if str(os.environ.get('VIZIERSERVER_DEBUG', "False")) == "True":
        print("PROVENANCE: {}".format(message))



class ModuleProvenance(object):
    """The module provenance object maintains information about the datasets
    that a module has read and written in previous executions as well as the
    datasets that the module has deleted. Read/write information is maintained
    in two dictionaries where the key is the dataset name. For datasets that a
    module read only the dataset identifier is maintained. For datasets that
    were created (written) by a module the dataset descriptor is maintained.
    Delete information is maintained as a list or set of dataset names.

    Note that the value that is associated with a name in either of the read
    or write dictionary may be None. This situation results for example from
    the execution of a python cell that attempted to read a dataset that did
    not exist or create a dataset that already existed.

    The module provenance carries a dictionary of key,value-pairs (resources)
    that were generated during previous executions of the module. This allows
    in a limited way to pass some state in between re-executions of the same
    module. The main intent is to pass information about downloaded files and
    the resulting dataset identifier to avoid re-downloading the files but to
    use the previously generated local copy instead.

    Provenance information is used to decide whether a module needs to be
    re-executed when a workflow is modified by inserting, replacing, or deleting
    modules.  Use method .requires_exec() if a module needs to be executed for
    a given database state. If provenance information is unknown (e.g., because
    the module has not been executed yet or it is treated as a black box) all
    the provenance dictionaries and lists are None. In that case the module
    will always require execution.
    """
    def __init__(self, 
            read: Optional[Dict[str,str]] = None, 
            write: Optional[Dict[str,ArtifactDescriptor]] = None, 
            delete: Optional[Set[str]] = None, 
            resources: Optional[Dict[str,Any]] = None, 
            charts: Optional[List[Tuple[str, ChartViewHandle]]] = None,
            unexecuted: bool = False
        ):
        """Initialize the datasets that were read and written by a previous
        module execution.

        Parameters
        ----------
        read: dict(string:string), optional
            Dictionary of datasets that the module used as input. The key is the
            dataset name and the value is the dataset descriptor.  None as the value
            indicates that the prior version of the specified dataset is unknown
            (i.e., will force re-execution always).
        write: dict(string:vizier.datastore.artifact.ArtifactDescriptor), optional
            Dictionary of datasets that the module modified. The key is the
            dataset name and the value the dataset identifier.  None as the value
            indicates a failed attempt at writing (i.e., will force re-execution
            always)
        delete: list(string) or set(string), optional
            List of names for datasets that have been deleted by a module
        resources: dict(string: scalar), optional
            Resources and other information that was generated during execution
        charts: list(string, vizier.view.chart.ChartViewHandle)
            List of charts that where generated by the module
        """
        self.unexecuted = unexecuted
        self.read: Optional[Dict[str,str]] = read
        self.write: Optional[Dict[str, ArtifactDescriptor]] = write
        self.delete: Set[str] = delete if delete is not None else set()
        self.resources: Dict[str, Any] = resources if resources is not None else dict()
        self.charts: List[Tuple[str, ChartViewHandle]] = charts if charts is not None else list()

    def __repr__(self) -> str:
        return "read: {}\nwrite: {}\ndelete: {}\nresources: {}\ncharts: {}".format(
            self.read,
            self.write,
            self.delete,
            self.resources,
            self.charts
        )

    def get_database_state(self, 
            prev_state: Dict[str, ArtifactDescriptor]
        ) -> Dict[str, ArtifactDescriptor]:
        """Adjust the database state after module execution. The dictionary of
        datasets contains names and identifier of datasets in the previous state
        of the database. To avoid reading descriptors for unchanged datasets
        from storage the database state of the previous module is used.

        The dataset state is adjusted based on the provenance information.

        Returns a dictionary that contains dataset descriptors for all datasets
        in the new database state. Dataset descriptors are keyed by the
        user-provided dataset name.

        Parameters
        ----------
        prev_state: dict(string:vizier.datastore.dataset.DatasetDescriptor)
            Dataset descriptors in previous state keyed by the user-provided
            name

        Returns
        -------
        dict(string:vizier.datastore.dataset.DatasetDescriptor)
        """
        next_state = dict(prev_state)
        # Remove deleted datasets
        if not self.delete is None:
            for name in self.delete:
                if name in next_state:
                    del next_state[name]
        # Add descriptors for written datasets
        if not self.write is None:
            for name in self.write:
                ds = self.write[name]
                if not ds is None:
                    next_state[name] = ds
        # print("{} + {} - {} -> {}".format(prev_state, self.write, self.delete, next_state))
        return next_state

    def requires_exec(self, 
            datasets: Dict[str, ArtifactDescriptor]
        ) -> bool:
        """Test if a module requires execution based on the provenance
        information and a given database state. If True, the module needs to be
        re-executes. Otherwise, the write dependencies can be copied to the new
        database state.

        If either of the read/write dependencies is None we always excute the
        module. Execution can be skipped if all previous inputs are present in
        the database state and if the module at most modifies the datasets that
        are in the set of read dependencies.

        Note that the identifier that are associated with dataset names may be
        None in the provenance information.

        Parameters
        ----------
        datasets: dict(vizier.datastore.dataset.DatasetDescriptor)
            Dictionary of identifier for datasets in the current state. The key
            is the dataset name.

        Returns
        -------
        bool
        """
        # Always execute if any of the provenance information for the module is
        # unknown (i.e., None)
        if self.unexecuted: 
            return True
        if self.read is None or self.write is None:
            debug("DEPENDENT / UNKNOWN ({}, {})".format(self.read, self.write))
            return True
        # Always execute if the module unsuccessfully attempted to write a
        # dataset or if it creates or changes a dataset that is not
        # in the read dependencies but that exists in the current state
        for name in self.write:
            if self.write[name] is None:
                debug("DEPENDENT / WRITE FAILED")
                return True
            elif name in datasets and name not in self.read:
                debug("DEPENDENT / OVERWRITE")
                return True
        # Check if all read dependencies are present and have not been modified
        for name in self.read:
            if not name in datasets:
                debug("DEPENDENT / READ MISSING")
                return True
            elif self.read[name] is None:
                debug("DEPENDENT / READ UNKNOWN")
                return True
            elif self.read[name] != datasets[name].identifier:
                debug("DEPENDENT / READ DIFFERENT")
                return True
        # If any dataset is being deleted that does not exist in the current
        # state we re-execute (because this may lead to an unwanted error state)
        if not self.delete is None:
            for name in self.delete:
                if not name in datasets:
                    debug("DEPENDENT / DELETED")
                    return True
        # The database state is the same as for the previous execution of the
        # module (with respect to the input dependencies). Thus, the module
        # does not need to be re-executed.
        debug("INDEPENDENT")
        return False
    