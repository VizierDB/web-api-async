# Copyright (C) 2017-2019 New York University,
#                         University at Buffalo,
#                         Illinois Institute of Technology.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Abstract base class fir the Vizier database client that enables access to
and manipulation of datasets in a datastore from within a Python script.
"""

from histore.document.schema import Column # type: ignore[import]
from vizier.filestore.base import CSV

from vizier.core.util import is_valid_name


class VizierDBClient(object):
    """The Vizier DB Client provides access to datasets that are identified by
    a unique name. The client is a wrapper around a given database state.
    """
    def __init__(self, datastore, datasets):
        """Initialize the reference to the data store backend and the existing
        datasets.

        Parameters
        ----------
        datastore: vizier.datastore.histore.base.HistoreDatastore
            HISTORE data store instance that maintains the datasets.
        datasets: dict
            Mapping of dataset names to unique persistent dataset identifier
            generated by the data store.
        """
        self.datastore = datastore
        self.datasets = dict(datasets)
        # Keep track of the descriptors of datasets that the client
        # successfully modified
        self.descriptors = dict()
        # Keep track of datasets that are read and written, deleted and
        # renamed.
        self.read = set()
        self.write = set()
        self.delete = None

    def checkout(self, name):
        """Get dataset with given name.

        Raises ValueError if the specified dataset does not exist.

        Parameters
        ----------
        name : string
            Unique dataset name

        Returns
        -------
        pandas.DataFrame
        """
        # Make sure to record access idependently of whether the dataset exists
        # or not. Ignore read access to datasets that have been written.
        if not name.lower() in self.write:
            self.read.add(name.lower())
        # Get identifier for the dataset with the given name. Will raise an
        # exception if the name is unknown
        identifier = self.get_dataset_identifier(name)
        # Read dataset from datastore and return it.
        ds = self.datastore.get_dataset(identifier)
        if ds is None:
            raise ValueError("unknown dataset '{}'".format(identifier))
        return ds.to_dataframe()

    def commit(self, name, dataset):
        """Update a given dataset.

        Raises ValueError if the specified dataset does not exist.

        Parameters
        ----------
        name : string
            Unique dataset name
        dataset : pandas.DataFrame
            Dataset object

        Returns
        -------
        pandas.DataFrame
        """
        # Get identifier for the dataset with the given name. Will raise an
        # exception if the name is unknown
        origin = self.get_dataset_identifier(name)
        ds = self.datastore.update_dataset(origin=origin, df=dataset)
        self.set_dataset_identifier(name, ds.identifier)
        self.descriptors[ds.identifier] = ds.descriptor()
        return ds.to_dataframe()

    def create(self, name, dataset, profiler=None):
        """Create a new dataset with given name.

        Raises ValueError if a dataset with given name already exist.

        Parameters
        ----------
        name : string
            Unique dataset name
        dataset : pandas.DataFrame
            Dataset object
        profiler: string, default=None
            Name of the data profiler for the new dataset.

        Returns
        -------
        pandas.DataFrame
        """
        # Raise an exception if a dataset with the given name already exists or
        # if the name is not valid
        if self.has_dataset_identifier(name):
            # Record access to the datasets
            self.read.add(name.lower())
            raise ValueError("dataset '{}' already exists".format(name))
        if not is_valid_name(name):
            raise ValueError("invalid dataset name '{}'".format(name))
        # Create identifiable column objects for the columns in the data frame
        # schema.
        schema = list()
        for column in dataset.columns:
            schema.append(Column(colid=len(schema), name=column))
        dataset.columns = schema
        # Write dataset to datastore and add new dataset to context
        ds = self.datastore.create_archive(df=dataset, profiler=profiler)
        self.set_dataset_identifier(name, ds.identifier)
        self.descriptors[ds.identifier] = ds.descriptor()
        return ds.to_dataframe()

    # Include for compatibility with previous syntax
    create_dataset = create

    def drop_dataset(self, name):
        """Remove the dataset with the given name.

        Raises ValueError if no dataset with given name exist.

        Parameters
        ----------
        name : string
            Unique dataset name
        """
        # Make sure to record access idependently of whether the dataset exists
        # or not. Ignore read access to datasets that have been written.
        if not name.lower() in self.write:
            self.read.add(name.lower())
        # Remove the context dataset identifier for the given name. Will raise
        # a ValueError if dataset does not exist
        if self.delete is None:
            self.delete = set()
        self.delete.add(name)
        self.remove_dataset_identifier(name)

    # Include for compatibility with previous syntax
    get_dataset = checkout

    def get_dataset_identifier(self, name):
        """Returns the unique identifier for the dataset with the given name.

        Raises ValueError if no dataset with the given name exists.

        Parameters
        ----------
        name: string
            Dataset name

        Returns
        -------
        string
        """
        # Datset names should be case insensitive
        key = name.lower()
        if key not in self.datasets:
            raise ValueError("unknown dataset '{}'".format(name))
        return self.datasets[key]

    def has_dataset_identifier(self, name):
        """Test whether a mapping for the dataset with the given name exists.

        Parameters
        ----------
        name: string
            Dataset name

        Returns
        -------
        bool
        """
        # Dataset names are case insensitive
        return name.lower() in self.datasets

    def load(self, name, filename, profiler=None):
        """Create a new dataset from a given file.

        Raises ValueError if a dataset with given name already exist.

        Parameters
        ----------
        name : string
            Unique dataset name
        filename : string
            Path to file on disk.
        profiler: string, default=None
            Name of the data profiler for the new dataset.

        Returns
        -------
        pandas.DataFrame
        """
        # Raise an exception if a dataset with the given name already exists or
        # if the name is not valid
        if self.has_dataset_identifier(name):
            # Record access to the datasets
            self.read.add(name.lower())
            raise ValueError("dataset '{}' already exists".format(name))
        if not is_valid_name(name):
            raise ValueError("invalid dataset name '{}'".format(name))
        # Write dataset to datastore and add new dataset to context
        ds = self.datastore.load_dataset(fh=CSV(filename), profiler=profiler)
        self.set_dataset_identifier(name, ds.identifier)
        self.descriptors[ds.identifier] = ds.descriptor()
        return ds.to_dataframe()

    def remove_dataset_identifier(self, name):
        """Remove the entry in the dataset dictionary that is associated with
        the given name. Raises ValueError if not dataset with name exists.

        Parameters
        ----------
        name: string
            Dataset name
        identifier: string
            Unique identifier for persistent dataset
        """
        # Convert name to lower case to ensure that names are case insensitive
        key = name.lower()
        if key not in self.datasets:
            raise ValueError("unknown dataset '{}'".format(name))
        del self.datasets[key]

    def rename_dataset(self, name, new_name):
        """Rename an existing dataset.

        Raises ValueError if a dataset with given name already exist.

        Raises ValueError if dataset with name does not exist or if dataset
        with new_name already exists.

        Parameters
        ----------
        name : string
            Unique dataset name
        new_name : string
            New dataset name
        """
        # Make sure to record access idependently of whether the dataset exists
        # or not. Ignore read access to datasets that have been written.
        if not name.lower() in self.write:
            self.read.add(name.lower())
        # Add the new name to the written datasets
        self.write.add(new_name.lower())
        # Raise exception if new_name exists or is not valid.
        if self.has_dataset_identifier(new_name):
            raise ValueError("dataset '{}' exists".format(new_name))
        if not is_valid_name(new_name):
            raise ValueError("invalid dataset name '{}'".format(new_name))
        # Raise an exception if no dataset with the given name exists
        identifier = self.get_dataset_identifier(name)
        self.drop_dataset(name)
        self.set_dataset_identifier(new_name, identifier)

    def set_dataset_identifier(self, name, identifier):
        """Sets the identifier to which the given dataset name points.

        Parameters
        ----------
        name: string
            Dataset name
        identifier: string
            Unique identifier for persistent dataset
        """
        # Convert name to lower case to ensure that names are case insensitive
        self.datasets[name.lower()] = identifier
        self.write.add(name.lower())

    # Include for compatibility with previous syntax
    update_dataset = commit
